\subsection*{Buscas Locais}

Heurísticas de melhoramento local são métodos de otimização que buscam 
aprimorar uma solução inicial através de pequenas modificações iterativas.
Essas técnicas são amplamente utilizadas em problemas combinatórios, 
como o Problema do Caixeiro Viajante (PCV), onde o objetivo é encontrar
a rota mais curta que visita um conjunto de cidades exatamente uma vez e 
retorna à cidade de origem.

A ideia principal das buscas locais é iterar através de soluções candidatas,
movendo-se para soluções vizinhas que apresentam uma melhoria em relação à
solução atual. Esse processo continua até que nenhuma melhoria adicional possa ser encontrada.
As etapas gerais de uma busca local incluem:
\begin{itemize}
    \item \textbf{Definição da Solução Inicial:} Uma solução inicial é gerada, geralmente por meio de uma heurística construtiva.
    \item \textbf{Geração de Vizinhança:} A vizinhança da solução atual é definida, o que envolve identificar todas as soluções que podem ser alcançadas através de pequenas modificações.
    \item \textbf{Avaliação das Soluções Vizinhas:} Cada solução na vizinhança é avaliada com base em um critério de qualidade (fitness).
    \item \textbf{Movimento para a Melhor Solução Vizinhança:} Se uma solução vizinha melhor for encontrada, a busca se move para essa solução e o processo se repete.
    \item \textbf{Critério de Parada:} A busca termina quando nenhuma melhoria adicional pode ser encontrada ou quando um critério de parada predefinido é atingido (como um número máximo de iterações).
\end{itemize}

Neste trabalho, implementamos quatro heurísticas de melhoramento local:
swap, shift, 2-opt e Or-opt. Cada uma dessas heurísticas opera de
maneira distinta para explorar o espaço de soluções e melhorar a qualidade 
da solução inicial gerada pelas heurísticas construtivas 
(Vizinho Mais Próximo e Inserção Mais Próxima). A implementação define um trait genérico 
\text{LocalSearch}, que abstrai as operações comuns entre as diferentes heurísticas de busca 
local.

O trait \text{LocalSearch} define a interface das buscas locais. Cada função dentro do trait 
recebe a solução atual, o grafo do problema e possíveis parâmetros adicionais, retornando uma
nova solução melhorada.

\begin{minted}{rust}
pub trait LocalSearch<Graph> {
    fn swap(&self, graph: &Graph, start: usize) -> Self;
    fn two_opt(&self, graph: &Graph) -> Self;
    fn shift(&self, graph: &Graph, start: usize) -> Self;
    fn or_opt(&self, graph: &Graph) -> Self;
}
\end{minted}

Cada uma das funções do trait opera sobre a solução corrente invocando, 
dentro da estrutura \texttt{Solution}, um método responsável por gerar a vizinhança 
correspondente ao tipo de busca local. Assim, a função \texttt{swap} utiliza 
\texttt{neighbourhood\_by\_swap}, \texttt{shift} invoca \texttt{neighbourhood\_by\_shift}, 
\texttt{two\_opt} utiliza \texttt{neighbourhood\_by\_two\_opt}, e \texttt{or\_opt} utiliza 
\texttt{neighbourhood\_by\_or\_opt}. A partir desse conjunto de soluções vizinhas, o método
seleciona a melhor candidata conforme o critério de custo, substituindo a solução atual 
quando uma melhoria é identificada. No que diz respeito à estratégia de seleção, 
as heurísticas \texttt{swap}, \texttt{shift} e \texttt{Or-opt} são implementadas no 
estilo \textit{best improvement}, avaliando todas as soluções vizinhas antes de escolher a
melhor. Já a heurística \texttt{2-opt} segue a estratégia \textit{first improvement}, 
atualizando a solução assim que encontra a primeira melhoria válida, o que reduz o tempo de
busca, embora possa resultar em ótimos locais de menor qualidade quando comparado ao 
método de melhor melhoria.

\subsubsection{Swap} 
\paragraph{Heurística Swap.}
A heurística \textit{swap} consiste em gerar uma vizinhança a partir da solução atual por 
meio da troca entre a cidade localizada em uma posição fixa da rota e cada uma das demais 
posições possíveis. Para cada troca realizada, uma solução candidata é produzida e avaliada 
com base no seu custo total. O método percorre todas as soluções vizinhas geradas pela função 
\texttt{neighbourhood\_by\_swap} e seleciona aquela que apresenta o menor custo. 
Caso esta solução seja melhor do que a solução corrente, a rota é atualizada e o processo 
é repetido, caracterizando um procedimento iterativo de melhoria contínua. A busca termina 
quando nenhuma troca adicional resulta em redução do custo, configurando um processo 
com estratégia de \textit{best improvement}, no qual 
a melhor solução vizinha é sempre escolhida como próximo passo de exploração.

\noindent\textbf{Observação:} Outras heurísticas implementadas que seguem a mesma abordagem
(\textit{best improvement}) ao varrer toda a vizinhança antes de aceitar uma mudança são
a heurística \textit{shift} (usando \texttt{neighbourhood\_by\_shift}) e a heurística
\textit{Or-opt} (usando \texttt{neighbourhood\_by\_or\_opt}).

\begin{minted}{rust}
fn neighbourhood_by_swap(&self, graph: &[[f64; N]; N], start: usize) -> Vec<Self> {
    let mut solutions: Vec<Solution<N>> = Vec::new();
    let n = self.route.len();
    if start >= n { return solutions; }

    // para cada posição diferente de `start`, troca as posições e calcula custo
    for i in 0..n {
        if i == start { continue; }
        let mut new_route = self.route.clone();
        new_route.swap(start, i); // troca os índices start e i

        let cost = Self::calculate_cost(&new_route, graph);
        solutions.push(Self { route: new_route, cost });
    }

    solutions
}
\end{minted}

\subsubsection{2-opt}
\paragraph{Heurística 2‑opt.}
A heurística 2‑opt opera removendo duas arestas do ciclo e reconectando os caminhos de forma
a reverter a ordem dos vértices entre os cortes. Esse operador tende a eliminar cruzamentos
na rota e promove mudanças estruturais mais significativas que uma simples troca de posições.
Ao contrário de \textit{swap}, \textit{shift} e \textit{Or-opt} (implementadas aqui com
estratégia de \textit{best improvement}), a implementação de 2‑opt neste trabalho usa a
estratégia de \textit{first improvement}: assim que é encontrada a primeira reversão que
reduz o custo, a solução é atualizada e a busca recomeça a partir da nova solução, isso
reduz o custo computacional por iteração, embora possa convergir para ótimos locais de
qualidade inferior ao método de melhor melhoria.

A vizinhança 2‑opt é gerada por \texttt{neighbourhood\_by\_two\_opt}, que itera todos os
pares \((i,j)\) com \(i<j\) e constrói a rota resultante da inversão do subtrecho entre
esses índices (implementação padrão: reverter o trecho \((i+1)..=j\)). Exemplo:

\begin{minted}{rust}
fn neighbourhood_by_two_opt(&self, graph: &[[f64; N]; N]) -> Vec<Self> {
    let mut neighbours: Vec<Solution<N>> = Vec::new();
    let n = self.route.len();
    if n < 2 { return neighbours; }

    for i in 0..(n - 1) {
        for j in (i + 1)..n {
            let mut new_route = self.route.clone();
            // 2‑opt padrão: reverter a parte interna entre i+1 e j
            if i + 1 <= j {
                new_route[(i + 1)..=j].reverse();
            }

            let cost = Self::calculate_cost(&new_route, graph);
            neighbours.push(Solution { route: new_route, cost });
        }
    }

    neighbours
}
\end{minted}

