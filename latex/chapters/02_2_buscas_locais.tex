\subsection*{Buscas Locais}

Heurísticas de melhoramento local são métodos de otimização que buscam 
aprimorar uma solução inicial através de pequenas modificações iterativas.
Essas técnicas são amplamente utilizadas em problemas combinatórios, 
como o Problema do Caixeiro Viajante (PCV), onde o objetivo é encontrar
a rota mais curta que visita um conjunto de cidades exatamente uma vez e 
retorna à cidade de origem.

A ideia principal das buscas locais é iterar através de soluções candidatas,
movendo-se para soluções vizinhas que apresentam uma melhoria em relação à
solução atual. Esse processo continua até que nenhuma melhoria adicional possa ser encontrada.
As etapas gerais de uma busca local incluem:
\begin{itemize}
    \item \textbf{Definição da Solução Inicial:} Uma solução inicial é gerada, geralmente por meio de uma heurística construtiva.
    \item \textbf{Geração de Vizinhança:} A vizinhança da solução atual é definida, o que envolve identificar todas as soluções que podem ser alcançadas através de pequenas modificações.
    \item \textbf{Avaliação das Soluções Vizinhas:} Cada solução na vizinhança é avaliada com base em um critério de qualidade (fitness).
    \item \textbf{Movimento para a Melhor Solução Vizinhança:} Se uma solução vizinha melhor for encontrada, a busca se move para essa solução e o processo se repete.
    \item \textbf{Critério de Parada:} A busca termina quando nenhuma melhoria adicional pode ser encontrada ou quando um critério de parada predefinido é atingido (como um número máximo de iterações).
\end{itemize}

Neste trabalho, implementamos quatro heurísticas de melhoramento local:
Swap, Shift, 2-opt e Or-opt. Cada uma dessas heurísticas opera de
maneira distinta para explorar o espaço de soluções e melhorar a qualidade 
da solução inicial gerada pelas heurísticas construtivas 
(Vizinho Mais Próximo e Inserção Mais Próxima). A implementação define um trait genérico 
\text{LocalSearch}, que abstrai as operações comuns entre as diferentes heurísticas de busca 
local.

O trait \text{LocalSearch} define a interface das buscas locais. Cada função dentro do trait 
recebe a solução atual, o grafo do problema e possíveis parâmetros adicionais, retornando uma
nova solução melhorada.

\begin{minted}{rust}
pub trait LocalSearch<Graph> {
    fn swap(&self, graph: &Graph, start: usize) -> Self;
    fn two_opt(&self, graph: &Graph) -> Self;
    fn shift(&self, graph: &Graph, start: usize) -> Self;
    fn or_opt(&self, graph: &Graph) -> Self;
}
\end{minted}

Tais funções acima podem ser classificadas de duas formas: \textbf{Best Improvement}, aquelas que otimizam ao máximo o custo do cenário inicial que lhe foi dado, ou \textbf{First Improvement}, que opera somente sobre a primeira oportunidade de otimização de custo encontrada. Ambas tem seus pontos fortes, esta tem um ganho inferior, mas em contrapartida sua complexidade é muito baixa, já essa gera otimizações melhores por conta de sua complexidade elevada.

Mas todas pertencem à categoria de \textbf{Busca Local} por um motivo, elas operam de maneira praticamente idêntica, divergindo apenas na forma em que enxerga e opera sobre sua vizinhança. Dito isso, foram implementadas as heurísticas \texttt{Swap}, \texttt{Shift} e \texttt{Or-opt} da categoria \textbf{Best Improvement} e apenas a \textbf{2-opt} da classe \textbf{First Improvement}. Sendo assim, dada a imensa semelhança entre a implementação das buscas, será dado enfoque na forma no qual estas enxergam sua vizinhança.

\subsubsection{Shift} 

Tal abordagem considera como vizinhança apenas os vizinhos diretos, ignorando os que não fazem fronteira com o nó atual da iteração. Ela escolhe um nó a ser removido e reconecta seus vizinhos, e após isso o insere em uma vizinhança que proporcione um melhor custo para a rota. Tudo isso acontece através da função \texttt{neighbourhood\_by\_shift}.


\begin{minted}{rust}
fn neighbourhood_by_shift(&self, graph: &[[f64; N]; N], start: usize) -> Vec<Self> {
    let mut solutions: Vec<Solution<N>> = Vec::new();
    let n = self.route.len();

    if start >= n {
        return solutions;
    }

    for target_pos in 0..n {
        if target_pos == start {
            continue;
        }

        let mut new_route = self.route.clone();  // copia a rota atual
        let elem = new_route.remove(start);      // remove o nó da sua vizinhança
        new_route.insert(target_pos, elem);      // adiciona ele em outra

        let cost = Self::calculate_cost(&new_route, graph);

        solutions.push(Self {
            route: new_route,
            cost,
        });
    }

    solutions
}
\end{minted}

\subsubsection{Swap} 
Consiste em gerar uma vizinhança a partir da solução atual por 
meio da troca entre a cidade localizada em uma posição fixa da rota e cada uma das demais 
posições possíveis. Para cada troca realizada, uma solução candidata é produzida e avaliada 
com base no seu custo total. O método percorre todas as soluções vizinhas geradas pela função 
\texttt{neighbourhood\_by\_swap} e seleciona aquela que apresenta o menor custo. 
Caso esta solução seja melhor do que a solução corrente, a rota é atualizada e o processo 
é repetido, caracterizando um procedimento iterativo de melhoria contínua. A busca termina 
quando nenhuma troca adicional resulta em redução do custo, configurando um processo 
com estratégia de \textit{best improvement}, no qual 
a melhor solução vizinha é sempre escolhida como próximo passo de exploração.

\begin{minted}{rust}
fn neighbourhood_by_swap(&self, graph: &[[f64; N]; N], start: usize) -> Vec<Self> {
    let mut solutions: Vec<Solution<N>> = Vec::new();
    let n = self.route.len();
    if start >= n { return solutions; }

    // para cada posição diferente de `start`, troca as posições e calcula custo
    for i in 0..n {
        if i == start { continue; }
        let mut new_route = self.route.clone();
        new_route.swap(start, i); // troca os índices start e i

        let cost = Self::calculate_cost(&new_route, graph);
        solutions.push(Self { route: new_route, cost });
    }

    solutions
}
\end{minted}

\subsubsection{Or-opt}
Tem como objetivo melhorar a solução atual por meio do deslocamento de 
subsequências contíguas da rota, normalmente de tamanho 1, 2 ou 3, para outras posições do 
percurso. Essa operação permite explorar movimentos mais amplos do que simples trocas ou 
deslocamentos unitários, oferecendo maior flexibilidade para escapar de ótimos locais 
superficiais. A função \texttt{neighbourhood\_by\_or\_opt} gera todas as soluções vizinhas 
possíveis ao remover um bloco da rota e reinseri-lo em outra posição válida. Cada vizinho é 
avaliado com base no custo total, e a melhor solução encontrada é comparada com a solução 
atual. Caso represente uma melhoria, a solução corrente é atualizada e o processo é repetido. 
Assim como em \textit{swap} e \textit{shift}, essa heurística opera segundo a estratégia de 
\textit{best improvement}, avaliando todas as alternativas da vizinhança antes de escolher a
melhor. A busca finaliza quando nenhuma realocação adicional de subsequências resulta em
redução do custo, atingindo um ótimo local sob essa vizinhança.

\begin{minted}{rust}
fn neighbourhood_by_or_opt(&self, graph: &[[f64; N]; N]) -> Vec<Self> {
    let n = self.route.len();
    let mut neighbours = Vec::new();

    for seq_len in 1..=3.min(n) {
        for i in 0..n {
            if i + seq_len > n {
                break;
            }

            for target in 0..n {
                if target >= i && target < i + seq_len {
                    continue;
                }

                let mut new_route = self.route.clone();
                let sequence: Vec<usize> = new_route.drain(i..(i + seq_len)).collect();

                let insert_pos = if target > i { target - seq_len } else { target };

                if insert_pos <= new_route.len() {
                    new_route.splice(insert_pos..insert_pos, sequence);

                    let cost = Self::calculate_cost(&new_route, graph);

                    neighbours.push(Solution {
                        route: new_route,
                        cost,
                    });
                }
            }
        }
    }

    neighbours
}
\end{minted}

\subsubsection{2-opt}
Esta opera removendo duas arestas do ciclo e reconectando os caminhos de forma
a reverter a ordem dos vértices entre os cortes. Esse operador tende a eliminar cruzamentos
na rota e promove mudanças estruturais mais significativas que uma simples troca de posições.
Ao contrário de \textit{swap}, \textit{shift} e \textit{Or-opt} (implementadas aqui com
estratégia de \textit{best improvement}), a implementação de 2‑opt neste trabalho usa a
estratégia de \textit{first improvement}: assim que é encontrada a primeira reversão que
reduz o custo, a solução é atualizada e a busca recomeça a partir da nova solução, isso
reduz o custo computacional por iteração, embora possa convergir para ótimos locais de
qualidade inferior ao método de melhor melhoria.

A vizinhança 2‑opt é gerada por \texttt{neighbourhood\_by\_two\_opt}, que itera todos os
pares \((i,j)\) com \(i<j\) e constrói a rota resultante da inversão do subtrecho entre
esses índices (implementação padrão: reverter o trecho \((i+1)..=j\)). Exemplo:
\begin{minted}{rust}
fn neighbourhood_by_two_opt(&self, graph: &[[f64; N]; N]) -> Vec<Self> {
    let mut neighbours: Vec<Solution<N>> = Vec::new();
    let n = self.route.len();
    if n < 2 { return neighbours; }

    for i in 0..(n - 1) {
        for j in (i + 1)..n {
            let mut new_route = self.route.clone();
            // 2‑opt padrão: reverter a parte interna entre i+1 e j
            if i + 1 <= j {
                new_route[(i + 1)..=j].reverse();
            }

            let cost = Self::calculate_cost(&new_route, graph);
            neighbours.push(Solution { route: new_route, cost });
        }
    }

    neighbours
}
\end{minted}
